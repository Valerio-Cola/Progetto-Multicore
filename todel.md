In questa implementazione il blocco di codice che è stato parallelizzato è quello della ricerca dei pattern.
Per definire il blocco di codice è stata utilizzata la direttiva pragma per condividere tra tutti i thread gli array pat_found e pat_matches. Mediante la sezione critica si protegge l'accesso concorrente alla funzione increment_matches, che si occupa di modificare seq_matches, la quale è fondamentale per evitare che nell'array ci siano valori inferiori alla fine dell'esecuzione.
Il primo ciclo for è stato parallelizzato poiché, nonostante i nostri tentativi, non siamo riusciti a parallelizzare anche i cicli annidati. Per utilizzare la clausola collapse() è necessario che i cicli siano perfettamente annidati senza istruzioni intermedie e non contengano break che interrompono i cicli. Inoltre, i domini degli ultimi due for si intersecano poiché la variabile pat viene utilizzata come condizione sia per questi cicli che come variabile di controllo del primo for. Questa dipendenza impedisce l'applicazione efficace della clausola collapse(), che richiede domini indipendenti e senza interferenze.
Assieme all'omp for sono state rese private le variabili di controllo di ogni ciclo for, è stata utilizzata una reduction per effettuare la somma di pat_matches alla fine del blocco parallelo poichè ogni thread calcola un determinato numero di pattern e incrementa privatamente quando ne trova uno.
Lo schedule utilizzato è dynamic poichè nei test le sequenze hanno lunghezza variabile, di conseguenza ogni thread potrebbe concludere il lavoro con tempistiche diverse.